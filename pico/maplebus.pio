;
; Copyright (c) 2021 Raul E Rangel
;
; SPDX-License-Identifier: GPL-2.0-or-later
;

.program maplebus_tx
.side_set 1 opt pindirs

; TX Encoding:
; | 31:28 | 27:0       |
; | Type  | Bit Phases |
;
; The first word in the sequence describes the parameters of the transaction.
; Type:
;    4  Simple Frame
;    5: Frame w/ CRC
;   13: Start Reset
; Bit Phases: The number of A/B phases to perform. This will be # bytes / 2.
;
; Autopull should be enabled on the TX FIFO with a threshold of 8.
;
; Pin mapping:
; - Set pin 0 is SDCKA
; - Side-set pin 0 is SDCKB
; - Out pin 0 is SDCKB
;
; SDCKA/SDCKB should have a pull-up enabled, OE inverted, and an output of 0.

public entry_point:

write_start_frame:
	out x, 4			; Read the frame type 
	set pindirs, 0		[7]	; Pull SDCKA low for 3 cycles.
start_frame_loop:
	nop		side 0	[7]	; Pull SDCKB low for 4 cycles.
	nop		side 1	[6]	; Pull SDCKB high for 3 cycles.
	jmp x--	start_frame_loop	; Start another iteration

start_bit_loop:
	set pindirs, 1			; Pull SDCKA high to end the start frame
	out x, 28		[2]	; Read the number of phase cycles and reset SDCKA
start_phase:
	out pindirs, 1		[3]	; Read the first bit to SDCKB
sdcka_tick:
	set pindirs, 0		[3]	; SDCKA falling clock edge
	nop		side 1	[1]	; SDCKB rising clock edge
	out y, 1			; Read the second bit in the cycle
	jmp !y, sdckb_0
sdckb_1:
	set pindirs, 1		[2]	; SDCKA data 1
	jmp sdckb_tick
sdckb_0:
	set pindirs, 0		[3]	; SDCKA data 0
sdckb_tick:
	nop		side 0	[3]	; SDCKB falling clock edge
	set pindirs, 1		[2]	; SDCKA rising clock edge
	jmp x--, start_phase
; .wrap
write_end_frame:
	nop		side 1	[7]	; SDCKB done
	nop		side 0	[7]	; SDCKB down to start end frame
	set pindirs, 0		[7]	; Pull SDCKA low for 4 cycles.
	set pindirs, 1		[7]	; Pull SDCKA high for 4 cycles.
	set pindirs, 0		[7]	; Pull SDCKA low for 4 cycles.
	set pindirs, 1		[7]	; Pull SDCKA high for 4 cycles.
	nop		side 1	[7]	; End frame done

% c-sdk {

#include "hardware/clocks.h"
#include "hardware/gpio.h"


static inline void maplebus_tx_program_init(PIO pio, uint sm, uint offset, uint pin_sdcka, uint pin_sdckb) {
    pio_sm_config c = maplebus_tx_program_get_default_config(offset);

    // IO mapping
    sm_config_set_set_pins(&c, pin_sdcka, 1);
    sm_config_set_sideset_pins(&c, pin_sdckb);
    sm_config_set_out_pins(&c, pin_sdckb, 1);

    // We need to clock out the MSB first, so we need to shift
    // to the left.
    sm_config_set_out_shift(&c, false, true, 8);

    // TODO: Remove the 1000 when we have a large pull-up.
    float div = (float)clock_get_hz(clk_sys) / (25000000) * 1000; 
    sm_config_set_clkdiv(&c, div);

    uint32_t both_pins = (1u << pin_sdcka) | (1u << pin_sdckb);
    pio_sm_set_pins_with_mask(pio, sm, 0, both_pins);
    pio_sm_set_pindirs_with_mask(pio, sm, both_pins, both_pins);
    pio_gpio_init(pio, pin_sdcka);
    gpio_set_oeover(pin_sdcka, GPIO_OVERRIDE_INVERT);
    pio_gpio_init(pio, pin_sdckb);
    gpio_set_oeover(pin_sdckb, GPIO_OVERRIDE_INVERT);

    gpio_pull_up(pin_sdcka);
    gpio_pull_up(pin_sdckb);

    // Clear IRQ flag before starting
    hw_clear_bits(&pio->inte0, 1u << sm);
    hw_clear_bits(&pio->inte1, 1u << sm);
    pio->irq = 1u << sm;

    // Configure and start SM
    pio_sm_init(pio, sm, offset + maplebus_tx_offset_entry_point, &c);
    pio_sm_set_enabled(pio, sm, true);
}

int pio_maplebus_tx_blocking(PIO pio, uint sm, uint8_t *buffer, size_t n) {
	uint32_t header = 0;
	header |= (0x3U << 28);
	header |= n * 8 / 2 - 1; // 4 cycles per byte
	pio_sm_put_blocking(pio, sm, header);

	for (size_t i = 0; i < n; ++i)
		pio_sm_put_blocking(pio, sm, (uint32_t)buffer[i] << 24);
}


%}

.program maplebus_rx
.side_set 1 opt
.origin 0

; Autopush should be disabled.
;
; Pin mapping:
; - Jump pin 0 is SDCKA
; - In pins are 0:SDCKB, 1:SDCKA

public entry_point:
	mov isr, !NULL			side 0	; Fill the ISR with 1s. We will shift 0 in for each
						; SDCKB falling edge.
	wait 1 pin 1				; Wait for SDCKA to be high.
	wait 0 pin 1				; A falling edge on SDCKA indicates the beginning
						; of the start frame.
wait_for_sdckb_falling_edge:
	jmp pin, verify_start_frame	side 1	; If SDCKA is high, we are done with the start frame
	mov osr, pins				; Read all the pins into OSR
	out x, 1				; Read SDCKB into x
	jmp !x, record_start_frame_falling_edge	; If SDCKB is 0 we found a falling edge
	jmp wait_for_sdckb_falling_edge		; SDCKB is still high, keep waiting
record_start_frame_falling_edge:
	in x, 1					; Shift 0/SDCKB into the ISR
wait_for_sdckb_rising_edge:
	jmp pin, verify_start_frame		; If SDCKA is high, the "start frame" is over
	mov osr, pins				; Read all the pins into OSR
	out x, 1				; Read SDCKB into x
	jmp !x, wait_for_sdckb_rising_edge	; If SDCKB is still 0, we keep waiting
	jmp wait_for_sdckb_falling_edge		; SDCKB is high, we found a rising edge, wait for a falling edge again.
verify_start_frame:
	mov osr, isr			side 0	; Copy the ISR into the OSR
	out NULL, 2				; We need at least 3 down ticks to consider it a start frame
	out x, 1				; Check the 3rd bit. If it's 0 we know we at least had 3 down ticks.
	jmp !x, start_data_phase		; We had a successful start frame
	jmp entry_point				; Not a valid start frame, continue
; So this gets a little complicated for the following reasons:
; * We don't have the instructions to monitor for an end frame condition.
;   Instead we loop forever and wait for the CPU to issue a `jmp entry_point`
;   when all the expected data has been read.
; * The maplebus protocol uses word length transfers. The exception is the
;   CRC byte at the end. We could use byte length transfers, but then the
;   endiness would be wrong and we would need to manually post process the
;   data. Instead we use two loops. An outer loop (y) that counts the number of
;   bytes that have been read, and an inner loop (x) that counts the number of
;   bits that have been read in the byte. By default we read in 4 byte
;   increments before pushing. When we want to read the CRC byte, the CPU
;   is expected to issue a `set y, 0` within 3 uS after the last full word
;   has been received. In other words, it we need to update the byte counter
;   before the full byte has been read and the counter evaluated.
;   The endiness of the CRC word will be wrong, so it will have to be shifted
;   by 24 bits.
; * Since we don't have enough instruction space, we combine the start frame
;   header push with the data push.
.wrap_target
start_data_phase:
	set y, 3				; Initialize the byte loop. We update this value before
						; pushing so the CPU can update this value before
						; the first byte has been fully read.
	push					; Push the start frame count or word.
read_data_phase:
	set x, 3			side 0	; Each byte is 8 bits, so 8/2 - 1 = 3
read_phase_1:
	wait 0 pin 1			side 1	; Wait for SDCKA falling edge
	in pins, 1				; Read data from SDCKB
	wait 1 pin 0				; Wait for SDCKB to be high
read_phase_2:
	wait 0 pin 0			side 0	; Wait for SDCKB falling edge
	mov osr, pins				; Read all the pins into OSR
	out NULL, 1				; Discard SDCKB
	in osr, 1				; Shift SDCKA into ISR
	wait 1 pin 1				; Wait for SDCKA to be high
decrement_counters:
	jmp x--, read_phase_1			; Check if we have read 8 bits
	jmp y--, read_data_phase		; Check if we have read finished reading the
						; required number of bytes.
.wrap

% c-sdk {

#include "hardware/clocks.h"
#include "hardware/gpio.h"


static inline void maplebus_rx_program_init(PIO pio, uint sm, uint offset, uint pin_sdcka, uint pin_sdckb) {
    assert(pin_sdcka == pin_sdckb + 1);
    pio_sm_set_consecutive_pindirs(pio, sm, pin_sdckb, 2, false);
    pio_sm_config c = maplebus_rx_program_get_default_config(offset);

    // IO mapping
    sm_config_set_in_pins(&c, pin_sdckb);
    sm_config_set_jmp_pin(&c, pin_sdcka);

    // We use the OSR as a temp register
    sm_config_set_out_shift(&c, true, false, 0);
    sm_config_set_in_shift(&c, false, false, 0);

    // We need to run fast so we can leave enough wiggle room for the
    // CPU to decide how much data it wants to read.
    float div = 1.0f;
    sm_config_set_clkdiv(&c, div);

    // Debug pin
    sm_config_set_sideset_pins(&c, 4); //debug pin
    pio_sm_set_consecutive_pindirs(pio, sm, 4, 1, true);
    pio_gpio_init(pio, 4);

    gpio_pull_up(pin_sdcka);
    gpio_pull_up(pin_sdckb);

    // Clear IRQ flag before starting
    hw_clear_bits(&pio->inte0, 1u << sm);
    hw_clear_bits(&pio->inte1, 1u << sm);
    pio->irq = 1u << sm;

    // Configure and start SM
    pio_sm_init(pio, sm, offset + maplebus_rx_offset_entry_point, &c);
    pio_sm_set_enabled(pio, sm, true);
}

int pio_maplebus_rx_blocking(PIO pio, uint sm, uint8_t *buffer, size_t n) {
	uint32_t val, header;
	if (n < 1)
		return -1;

	printf("Waiting for val\n");
	val = pio_sm_get_blocking(pio, sm);
	printf("RX: Got frame: %#x\n", val);

	if (val == 0xFFFFFFF0) { // Start frame w/ CRC
		val = pio_sm_get_blocking(pio, sm);
		// Update the expected number of bytes to 1
		pio_sm_exec(pio, sm, pio_encode_set(pio_y, 0));
		printf("HDR: %#x\n", val);

		val = pio_sm_get_blocking(pio, sm);
		printf("CRC: %#x\n", val);

		// We need to manually reset the PC
		pio_sm_exec(pio, sm, pio_encode_jmp(0));
	} else {
		pio_sm_put_blocking(pio, sm, 0);
		printf("RX: Unknown start frame: %#x\n", val);
	}
}


%}

