;
; Copyright (c) 2021 Raul E Rangel
;
; SPDX-License-Identifier: GPL-2.0-or-later
;

.program maplebus_tx
.side_set 1 opt pindirs

; TX Encoding:
; | 31:28 | 27:0       |
; | Type  | Bit Phases |
;
; The first word in the sequence describes the parameters of the transaction.
; Type:
;    4  Simple Frame
;    5: Frame w/ CRC
;   13: Start Reset
; Bit Phases: The number of A/B phases to perform. This will be # bytes / 2.
;
; Autopull should be enabled on the TX FIFO with a threshold of 8.
;
; Pin mapping:
; - Set pin 0 is SDCKA
; - Side-set pin 0 is SDCKB
; - Out pin 0 is SDCKB
;
; SDCKA/SDCKB should have a pull-up enabled, OE inverted, and an output of 0.

public entry_point:

write_start_frame:
	out x, 4			; Read the frame type 
	set pindirs, 0		[7]	; Pull SDCKA low for 3 cycles.
start_frame_loop:
	nop		side 0	[7]	; Pull SDCKB low for 4 cycles.
	nop		side 1	[6]	; Pull SDCKB high for 3 cycles.
	jmp x--	start_frame_loop	; Start another iteration

start_bit_loop:
	set pindirs, 1			; Pull SDCKA high to end the start frame
	out x, 28		[2]	; Read the number of phase cycles and reset SDCKA
start_phase:
	out pindirs, 1		[3]	; Read the first bit to SDCKB
sdcka_tick:
	set pindirs, 0		[3]	; SDCKA falling clock edge
	nop		side 1	[1]	; SDCKB rising clock edge
	out y, 1			; Read the second bit in the cycle
	jmp !y, sdckb_0
sdckb_1:
	set pindirs, 1		[2]	; SDCKA data 1
	jmp sdckb_tick
sdckb_0:
	set pindirs, 0		[3]	; SDCKA data 0
sdckb_tick:
	nop		side 0	[3]	; SDCKB falling clock edge
	set pindirs, 1		[2]	; SDCKA rising clock edge
	jmp x--, start_phase
; .wrap
write_end_frame:
	nop		side 1	[7]	; SDCKB done
	nop		side 0	[7]	; SDCKB down to start end frame
	set pindirs, 0		[7]	; Pull SDCKA low for 4 cycles.
	set pindirs, 1		[7]	; Pull SDCKA high for 4 cycles.
	set pindirs, 0		[7]	; Pull SDCKA low for 4 cycles.
	set pindirs, 1		[7]	; Pull SDCKA high for 4 cycles.
	nop		side 1	[7]	; End frame done

% c-sdk {

#include "hardware/clocks.h"
#include "hardware/gpio.h"


static inline void maplebus_program_init(PIO pio, uint sm, uint offset, uint pin_sdcka, uint pin_sdckb) {
    pio_sm_config c = maplebus_tx_program_get_default_config(offset);

    // IO mapping
    sm_config_set_set_pins(&c, pin_sdcka, 1);
    sm_config_set_sideset_pins(&c, pin_sdckb);
    sm_config_set_out_pins(&c, pin_sdckb, 1);

    // We need to clock out the MSB first, so we need to shift
    // to the left.
    sm_config_set_out_shift(&c, false, true, 8);

    // TODO: Remove the 1000 when we have a large pull-up.
    float div = (float)clock_get_hz(clk_sys) / (25000000) * 1000; 
    sm_config_set_clkdiv(&c, div);

    uint32_t both_pins = (1u << pin_sdcka) | (1u << pin_sdckb);
    pio_sm_set_pins_with_mask(pio, sm, 0, both_pins);
    pio_sm_set_pindirs_with_mask(pio, sm, both_pins, both_pins);
    pio_gpio_init(pio, pin_sdcka);
    gpio_set_oeover(pin_sdcka, GPIO_OVERRIDE_INVERT);
    pio_gpio_init(pio, pin_sdckb);
    gpio_set_oeover(pin_sdckb, GPIO_OVERRIDE_INVERT);

    gpio_pull_up(pin_sdcka);
    gpio_pull_up(pin_sdckb);

    // Clear IRQ flag before starting
    hw_clear_bits(&pio->inte0, 1u << sm);
    hw_clear_bits(&pio->inte1, 1u << sm);
    pio->irq = 1u << sm;

    // Configure and start SM
    pio_sm_init(pio, sm, offset + maplebus_tx_offset_entry_point, &c);
    pio_sm_set_enabled(pio, sm, true);
}

int pio_maplebus_tx_blocking(PIO pio, uint sm, uint8_t *buffer, size_t n) {
	uint32_t header = 0;
	header |= (0x3U << 28);
	header |= n * 8 / 2 - 1; // 4 cycles per byte
	pio_sm_put_blocking(pio, sm, header);

	for (size_t i = 0; i < n; ++i)
		pio_sm_put_blocking(pio, sm, (uint32_t)buffer[i] << 24);
}


%}

